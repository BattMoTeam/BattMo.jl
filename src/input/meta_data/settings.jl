export get_setting_meta_data


function get_setting_meta_data()
	meta_data = Dict(
		"ModelFramework" => Dict(
			"type" => String,
			"options" => ["P2D", "P4D Pouch", "P4D Cylindrical"],
			"context_type" => "ModelFramework",
			"context_type_iri" => "https://w3id.org/emmo/domain/battery#battery_b1921f7b_afac_465a_a275_26f929f7f936",
			"is_sub_model" => true,
			"documentation" => "https://battmoteam.github.io/BattMo.jl/dev/manuals/user_guide/pxd_model",
			"description" => """Framework defining the dimensionality of the electrochemical model. Examples: "P2D", "P4D Pouch". """,
		),
		"SEIModel" => Dict(
			"type" => String,
			"options" => ["Bolay"],
			"is_sub_model" => true,
			"context_type_iri" => nothing,
			"description" => """Which SEI model is used. For instance: "Bolay" """,
			"documentation" => "https://battmoteam.github.io/BattMo.jl/dev/manuals/user_guide/sei_model",
		),
		"PotentialFlowDiscretization" => Dict(
			"type" => String,
			"options" => ["GeneralAD", "TwoPointDiscretization"],
			"is_sub_model" => true,
			"context_type_iri" => nothing,
			"description" => """Specifies the numerical backend used for solving the potential flow equations. 
								The GenericAD option uses a general automatic differentiation approach that is robust and widely applicable, 
								while the TwoPointDiscretization option applies a specialized two-point flux discretization of the conservation laws, 
									which can be faster but is less general. We recommend using GenericAD unless performance considerations dictate otherwise.""",
			"documentation" => "",
		),
		"ButlerVolmer" => Dict(
			"type" => String,
			"options" => ["Standard", "Chayambuka"],
			"context_type" => "ButlerVolmerEquation",
			"context_type_iri" => "https://w3id.org/emmo/domain/battery#battery_b1921f7b_afac_465a_a275_26f929f7f936",
			"is_sub_model" => true,
			"documentation" => "https://battmoteam.github.io/BattMo.jl/dev/manuals/user_guide/pxd_model",
			"description" => """When set to Chayambuka, the slightly adapted butler volmer equation from reference [Chayambuka2020](https://www.sciencedirect.com/science/article/pii/S0013468621020478?via%3Dihub) will be selected within the model.""",
		),
		"TransportInSolid" => Dict(
			"type" => String,
			"options" => ["FullDiffusion"],
			"is_sub_model" => true,
			"context_type_iri" => nothing,
			"description" => """Which model is used to describe the intercalant diffusion in the solid particles. Example "FullDiffusion". """,
		),
		"CurrentCollectors" => Dict(
			"type" => String,
			"options" => ["Standard"],
			"context_type" => "CurrentCollectors",
			"context_type_iri" => nothing,
			"is_sub_model" => true,
			"description" => "Which model describes the current collectors.",
		),
		"GridResolutionHeight" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 100,
			"context_type" => "Cell",
			"context_type_iri" => nothing,
			"description" => "Number of grid points along the height of the cell (used in P4D cylindrical)",
		),
		"GridResolutionAngular" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 100,
			"context_type" => "Cell",
			"context_type_iri" => nothing,
			"description" => "Number of discretisation angles for a cylindrical cell (used in P4D cylindrical)",
		),
		"GridResolutionElectrodeWidth" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type" => "GridResolutionPositiveElectrode",
			"context_type_iri" => nothing,
			"description" => "Number of grid points along the width dimension of the electrode.",
		),
		"GridResolutionElectrodeLength" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => nothing,
			"description" => "Number of grid points along the length dimension of the electrode.",
		),
		"GridResolutionPositiveElectrodeCoating" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => nothing,
			"description" => "Number of grid points along the thickness dimension of the positive electrode.",
		),
		"GridResolutionPositiveElectrodeParticle" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => nothing,
			"description" => "Number of grid points along the radial pseudo dimension of the positive electrode active material particles.",
		),
		"GridResolutionNegativeElectrodeCoating" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => nothing,
			"description" => "Number of grid points along the thickness dimension of the negative electrode.",
		),
		"GridResolutionPositiveElectrodeCurrentCollector" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => nothing,
			"description" => "Number of grid points along the thickness dimension of the positive electrode current collector.",
		),
		"GridResolutionPositiveElectrodeCurrentCollectorTabWidth" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => nothing,
			"description" => "In the current collector tab at the positive electrode, the number of grid points along the width dimension of the tab's face.",
		),
		"GridResolutionPositiveElectrodeCurrentCollectorTabLength" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => "https://w3id.org/emmo/domain/electrochemistry#electrochemistry_47608fd0_cc0d_457e_9141_051935029e3a",
			"description" => "In the current collector tab at the positive electrode, the number of grid points along the length dimension of the tab's face.",
		),
		"GridResolutionNegativeElectrodeCurrentCollector" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => "https://w3id.org/emmo/domain/electrochemistry#electrochemistry_47608fd0_cc0d_457e_9141_051935029e3a",
			"description" => "Number of grid points along the thickness dimension of the negative electrode current collector.",
		),
		"GridResolutionNegativeElectrodeCurrentCollectorTabWidth" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => "https://w3id.org/emmo/domain/electrochemistry#electrochemistry_47608fd0_cc0d_457e_9141_051935029e3a",
			"description" => "In the current collector tab at the negative electrode, the number of grid points along the width dimension of the tab's face.",
		),
		"GridResolutionNegativeElectrodeCurrentCollectorTabLength" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => "https://w3id.org/emmo/domain/electrochemistry#electrochemistry_47608fd0_cc0d_457e_9141_051935029e3a",
			"description" => "In the current collector tab at the negative electrode, the number of grid points along the length dimension of the tab's face.",
		),
		"GridResolutionNegativeElectrodeParticle" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => "https://w3id.org/emmo/domain/electrochemistry#electrochemistry_47608fd0_cc0d_457e_9141_051935029e3a",
			"description" => "Number of grid points along the radial pseudo dimension of the negative electrode active material particles.",
		),
		"GridResolutionSeparator" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 1000,
			"context_type_iri" => "https://w3id.org/emmo/domain/electrochemistry#electrochemistry_47608fd0_cc0d_457e_9141_051935029e3a",
			"description" => "Number of grid points along the thickness dimension of the separator.",
		),
		"Grid" => Dict(
			"type" => Vector,
			"context_type" => "Grid",
			"context_type_iri" => nothing,
			"description" => "Vector storing the numerical representation of the computational grid discretizing the spatial representation of the cell.",
		),
		"RampUp" => Dict(
			"type" => String,
			"options" => ["Sinusoidal"],
			"context_type" => "RampUp",
			"context_type_iri" => "https://w3id.org/emmo/domain/electrochemistry#electrochemistry_rampup",
			"documentation" => "https://battmoteam.github.io/BattMo.jl/dev/manuals/user_guide/ramp_up",
			"is_sub_model" => true,
			"description" => """Type of signal of electric current used to initialize the cell simulation. Example: "Sinusoidal".""",
		),
		"RampUpSteps" => Dict(
			"type" => Int,
			"min_value" => 1,
			"max_value" => 100,
			"context_type" => "RampUpSteps",
			"context_type_iri" => "https://w3id.org/emmo/domain/electrochemistry#electrochemistry_rampup_steps",
			"description" => "Number of ramp-up steps applied to initialize the cell simulation.",
		),
		"RampUpTime" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 500,
			"unit" => "s",
			"unit_name" => "emmo:Second",
			"context_type" => "RampUpTime",
			"context_type_iri" => nothing,
			"description" => "Ramp up time duration applied to initialize the cell simulation.",
		),
		"TimeStepDuration" => Dict(
			"max_value" => 500,
			"min_value" => 1,
			"context_type" => "StepDuration",
			"context_type_iri" => "https://w3id.org/emmo/domain/electrochemistry#electrochemistry_85e39686_9658_4c74_bb91_a935704c174a",
			"description" => "Duration of each time step in simulations",
			"type" => Real,
			"unit" => "s",
			"unit_name" => "emmo:Second",
			"unit_iri" => "https://w3id.org/emmo/domain/emmo#Second",
		),
		"MaxTimestepCuts" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10000,
			"description" => "Maximum time step cuts in a single mini step before termination of simulation.",
		),
		"MaxTimestep" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 1e100,
			"description" => "Maximum time step length.",
		),
		"MinTimestep" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 1000,
			"description" => "Minimum time step length.",
		),
		"TimestepMaxIncrease" => Dict(
			"type" => Real,
			"min_value" => 0,
			"max_value" => 100,
			"description" => "Max allowable factor to increase time-step by. Overrides step selectors.",
		),
		"TimestepMaxDecrease" => Dict(
			"type" => Real,
			"min_value" => 0,
			"max_value" => 100,
			"description" => "Max allowable factor to decrease time-step by. Overrides step selectors.",
		),
		"MaxNonLinearIterations" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10000,
			"description" => "Max number of nonlinear iterations in a Newton solve before time-step is cut.",
		),
		"MaxLinearIterations" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10000,
			"description" => "Max number of linear iterations in a Newton solve before time-step is cut.",
		),
		"MinNonLinearIterations" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 100000000,
			"description" => "Minimum number of nonlinear iterations in Newton solver. This number of Newtion iterations is always performed, even if all equations are converged.",
		),
		"MaxSize" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10000000,
			"description" => "Maximum size for linear solver.",
		),
		"Verbosity" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10000,
			"description" => "Verbosity for linear solver.",
		),
		"Method" => Dict(
			"type" => String,
			"options" => ["direct", "iterative"],
			"description" => "Linear solver method.",
		),
		"FailureCutsTimesteps" => Dict(
			"type" => Bool,
			"options" => [true, false],
			"description" => "Cut the timestep if exceptions occur during step. If set to false, throw errors and terminate.",
		),
		"CheckBeforeSolve" => Dict(
			"type" => Bool,
			"options" => [true, false],
			"description" => "Check convergence before solving linear system. Can skip some linear solves if not using increment tolerances.",
		),
		"AlwaysUpdateSecondary" => Dict(
			"type" => Bool,
			"options" => [true, false],
			"description" => "Always update secondary variables (even when they can be reused from end of previous step). Only useful for nested solvers",
		),
		"ErrorOnIncomplete" => Dict(
			"type" => Bool,
			"options" => [true, false],
			"description" => "Throw an error if the simulation could not complete. If `false` emit a message and return.",
		),
		"CuttingCriterion" => Dict(
			"type" => Nothing,
			"description" => "Criterion to use for early cutting of time-steps. Default value of nothing means cutting when max_nonlinear_iterations is reached.",
		),
		"Tolerances" => Dict(
			"type" => Dict,
			"min_value" => 1e-40,
			"max_value" => 1,
			"description" => "Tolerances used for convergence criterions.",
		),
		"LinearTolerance" => Dict(
			"type" => Real,
			"min_value" => 1e-40,
			"max_value" => 1,
			"description" => "Tolerance used for convergence criterions.",
		),
		"TolFactorFinalIteration" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10,
			"description" => "Value that multiplies all tolerances for the final convergence check before a time-step is cut.",
		),
		"SafeMode" => Dict(
			"type" => Bool,
			"options" => [true, false],
			"description" => "Add extra checks in simulator that have a small extra cost.",
		),
		"LinearSolver" => Dict(
			"type" => Dict,
			"description" => "The linear solver used to solve linearized systems.",
		),
		"ExtraTiming" => Dict(
			"type" => Bool,
			"options" => [true, false],
			"description" => "Output extra, highly detailed performance report at simulation end.",
		),
		"TimeStepSelectors" => Dict(
			"type" => String,
			"options" => ["TimestepSelector"],
			"description" => "Time-step selectors that pick mini steps.",
		),
		"Relaxation" => Dict(
			"type" => String,
			"options" => ["NoRelaxation", "SimpleRelaxation"],
			"description" => "Non-Linear relaxation used. Currently supports `NoRelaxation()` and `SimpleRelaxation()`.",
		),
		"InfoLevel" => Dict(
			"type" => Int,
			"min_value" => -1,
			"max_value" => 4,
			"description" => """Info level determines the amount of runtime output to the terminal during simulation.
				0 - gives minimal output (just a progress bar by default, and a final report)
				1 - gives some more details, printing at the start of each step
				2 - as 1, but also printing the current worst residual at each iteration
				3 - as 1, but prints a table of all non-converged residuals at each iteration
				4 - as 3, but all residuals are printed (even converged values)
				Negative values disable output. The interpretation of this number is subject to change.""",
		),
		"DebugLevel" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10,
			"description" => "Define the amount of debug output in the reports. Higher values means more output.",
		),
		"EndReport" => Dict(
			"type" => Nothing,
			"description" => "Output a final report that includes timings etc. If nothing, depends on info_level instead.",
		),
		"ASCIITerminal" => Dict(
			"type" => Bool,
			"description" => "Avoid unicode (if possible) in terminal output.",
		),
		"ID" => Dict(
			"type" => String,
			"description" => "String identifier for simulator that is prefixed to some verbose output.",
		),
		"ProgressColor" => Dict(
			"type" => String,
			"description" => "Color for progress meter.",
		),
		"progress_glyphs" => Dict(
			"type" => String,
			"options" => ["default"],
			"description" => "Glyphs",
		),
		"OutputStates" => Dict(
			"type" => Bool,
			"description" => "Return states in-memory as output.",
		),
		"OutputReports" => Dict(
			"type" => Bool,
			"description" => "Return reports in-memory as output.",
		),
		"OutputPath" => Dict(
			"type" => String,
			"description" => "Path to write output. If nothing, output is not written to disk.",
		),
		"InMemoryReports" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10,
			"description" => "Limit for number of reports kept in memory if output_path is provided.",
		),
		"ReportLevel" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10,
			"description" => "Level of information stored in reports when written to disk.",
		),
		"OutputSubstrates" => Dict(
			"type" => Bool,
			"description" => "Store substates (between report steps) as field on each state.",
		),
	)

	return meta_data
end
