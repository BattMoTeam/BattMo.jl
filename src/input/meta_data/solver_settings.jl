export get_solver_settings_meta_data

function get_solver_settings_meta_data()

	meta_data = Dict(
		"MaxTimestepCuts" => Dict(
			"type" => Int,
			"variable_name" => "max_timestep_cuts",
			"min_value" => 0,
			"max_value" => 10000,
			"category" => "SolverSettings",
			"description" => "Maximum time step cuts in a single mini step before termination of simulation.",
		),
		"MaxTimestep" => Dict(
			"type" => Int,
			"variable_name" => "max_timestep",
			"min_value" => 0,
			"max_value" => 1e100,
			"category" => "SolverSettings",
			"description" => "Maximum time step length.",
		),
		"MinTimestep" => Dict(
			"type" => Int,
			"variable_name" => "min_timestep",
			"min_value" => 0,
			"max_value" => 1000,
			"category" => "SolverSettings",
			"description" => "Minimum time step length.",
		),
		"TimestepMaxIncrease" => Dict(
			"type" => Real,
			"variable_name" => "timestep_max_increase",
			"min_value" => 0,
			"max_value" => 100,
			"category" => "SolverSettings",
			"description" => "Max allowable factor to increase time-step by. Overrides step selectors.",
		),
		"TimestepMaxDecrease" => Dict(
			"type" => Real,
			"variable_name" => "timestep_max_decrease",
			"min_value" => 0,
			"max_value" => 100,
			"category" => "SolverSettings",
			"description" => "Max allowable factor to decrease time-step by. Overrides step selectors.",
		),
		"MaxNonLinearIterations" => Dict(
			"type" => Int,
			"variable_name" => "max_nonlinear_iterations",
			"min_value" => 0,
			"max_value" => 10000,
			"category" => "SolverSettings",
			"description" => "Max number of nonlinear iterations in a Newton solve before time-step is cut.",
		),
		"MaxLinearIterations" => Dict(
			"type" => Int,
			"variable_name" => "max_linear_iterations",
			"min_value" => 0,
			"max_value" => 10000,
			"category" => "SolverSettings",
			"description" => "Max number of linear iterations in a Newton solve before time-step is cut.",
		),
		"MinNonLinearIterations" => Dict(
			"type" => Int,
			"variable_name" => "min_nonlinear_iterations",
			"min_value" => 0,
			"max_value" => 100000000,
			"category" => "SolverSettings",
			"description" => "Minimum number of nonlinear iterations in Newton solver. This number of Newtion iterations is always performed, even if all equations are converged.",
		),
		"MaxSize" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10000000,
			"category" => "SolverSettings",
			"description" => "Maximum size for linear solver.",
		),
		"Verbosity" => Dict(
			"type" => Int,
			"min_value" => 0,
			"max_value" => 10000,
			"category" => "SolverSettings",
			"description" => "Verbosity for linear solver.",
		),
		"Method" => Dict(
			"type" => String,
			"options" => ["Direct", "Iterative", "UserDefined"],
			"category" => "SolverSettings",
			"description" => "Linear solver method.",
		),
		"FailureCutsTimesteps" => Dict(
			"type" => Bool,
			"variable_name" => "failure_cuts_timestep",
			"options" => [true, false],
			"category" => "SolverSettings",
			"description" => "Cut the timestep if exceptions occur during step. If set to false, throw errors and terminate.",
		),
		"CheckBeforeSolve" => Dict(
			"type" => Bool,
			"variable_name" => "check_before_solve",
			"options" => [true, false],
			"category" => "SolverSettings",
			"description" => "Check convergence before solving linear system. Can skip some linear solves if not using increment tolerances.",
		),
		"AlwaysUpdateSecondary" => Dict(
			"type" => Bool,
			"variable_name" => "always_update_secondary",
			"options" => [true, false],
			"category" => "SolverSettings",
			"description" => "Always update secondary variables (even when they can be reused from end of previous step). Only useful for nested solvers",
		),
		"ErrorOnIncomplete" => Dict(
			"type" => Bool,
			"variable_name" => "error_on_incomplete",
			"options" => [true, false],
			"category" => "SolverSettings",
			"description" => "Throw an error if the simulation could not complete. If `false` emit a message and return.",
		),
		"CuttingCriterion" => Dict(
			"type" => Nothing,
			"variable_name" => "cutting_criterion",
			"category" => "SolverSettings",
			"description" => "Criterion to use for early cutting of time-steps. Default value of nothing means cutting when max_nonlinear_iterations is reached.",
		),
		"Tolerances" => Dict(
			"type" => Dict,
			"variable_name" => "tolerances",
			"min_value" => 1e-40,
			"max_value" => 1,
			"category" => "SolverSettings",
			"description" => "Tolerances used for convergence criterions.",
		),
		"LinearTolerance" => Dict(
			"type" => Real,
			"variable_name" => "linear_tolerance",
			"min_value" => 1e-40,
			"max_value" => 1,
			"category" => "SolverSettings",
			"description" => "Tolerance used for convergence criterions.",
		),
		"TolFactorFinalIteration" => Dict(
			"type" => Int,
			"variable_name" => "tol_factor_final_iteration",
			"min_value" => 0,
			"max_value" => 10,
			"category" => "SolverSettings",
			"description" => "Value that multiplies all tolerances for the final convergence check before a time-step is cut.",
		),
		"SafeMode" => Dict(
			"type" => Bool,
			"variable_name" => "safe_mode",
			"options" => [true, false],
			"category" => "SolverSettings",
			"description" => "Add extra checks in simulator that have a small extra cost.",
		),
		"LinearSolver" => Dict(
			"type" => Dict,
			"variable_name" => "linear_solver",
			"category" => "SolverSettings",
			"description" => "The linear solver used to solve linearized systems.",
		),
		"ExtraTiming" => Dict(
			"type" => Bool,
			"variable_name" => "extra_timing",
			"options" => [true, false],
			"category" => "SolverSettings",
			"description" => "Output extra, highly detailed performance report at simulation end.",
		),
		"TimeStepSelectors" => Dict(
			"type" => String,
			"variable_name" => "timestep_selectors",
			"options" => ["TimestepSelector"],
			"category" => "SolverSettings",
			"description" => "Time-step selectors that pick mini steps.",
		),
		"Relaxation" => Dict(
			"type" => String,
			"variable_name" => "relaxation",
			"options" => ["NoRelaxation", "SimpleRelaxation"],
			"category" => "SolverSettings",
			"description" => "Non-Linear relaxation used. Currently supports `NoRelaxation()` and `SimpleRelaxation()`.",
		),
		"InfoLevel" => Dict(
			"type" => Int,
			"variable_name" => "info_level",
			"min_value" => -1,
			"max_value" => 4,
			"category" => "SolverSettings",
			"description" => """Info level determines the amount of runtime output to the terminal during simulation.
								0  - gives minimal output (just a progress bar by default, and a final report)
								1  - gives some more details, printing at the start of each step
								2  - as 1, but also printing the current worst residual at each iteration
								3  - as 1, but prints a table of all non-converged residuals at each iteration
								4  - as 3, but all residuals are printed (even converged values)
								-1 - disables output. """,
		),
		"DebugLevel" => Dict(
			"type" => Int,
			"variable_name" => "debug_level",
			"min_value" => 0,
			"max_value" => 10,
			"category" => "SolverSettings",
			"description" => "Define the amount of debug output in the reports. Higher values means more output.",
		),
		"EndReport" => Dict(
			"type" => Nothing,
			"variable_name" => "end_report",
			"category" => "SolverSettings",
			"description" => "Output a final report that includes timings etc. If nothing, depends on info_level instead.",
		),
		"ASCIITerminal" => Dict(
			"type" => Bool,
			"variable_name" => "ascii_terminal",
			"category" => "SolverSettings",
			"description" => "Avoid unicode (if possible) in terminal output.",
		),
		"ID" => Dict(
			"type" => String,
			"variable_name" => "id",
			"category" => "SolverSettings",
			"description" => "String identifier for simulator that is prefixed to some verbose output.",
		),
		"ProgressColor" => Dict(
			"type" => String,
			"variable_name" => "progress_color",
			"category" => "SolverSettings",
			"description" => "Color for progress meter.",
		),
		"progress_glyphs" => Dict(
			"type" => String,
			"variable_name" => "progress_glyphs",
			"options" => ["default"],
			"category" => "SolverSettings",
			"description" => "Glyphs",
		),
		"OutputStates" => Dict(
			"type" => Bool,
			"variable_name" => "output_states",
			"category" => "SolverSettings",
			"description" => "Return states in-memory as output.",
		),
		"OutputReports" => Dict(
			"type" => Bool,
			"variable_name" => "output_reports",
			"category" => "SolverSettings",
			"description" => "Return reports in-memory as output.",
		),
		"OutputPath" => Dict(
			"type" => String,
			"variable_name" => "output_path",
			"category" => "SolverSettings",
			"description" => "Path to folder in which the output should be written. The output will be givin in JLD2 files which adhere to the HDF5 format. If nothing, output is not written to disk.",
		),
		"InMemoryReports" => Dict(
			"type" => Int,
			"variable_name" => "in_memory_reports",
			"min_value" => 0,
			"max_value" => 10,
			"category" => "SolverSettings",
			"description" => "Limit for number of reports kept in memory if output_path is provided.",
		),
		"ReportLevel" => Dict(
			"type" => Int,
			"variable_name" => "report_level",
			"min_value" => 0,
			"max_value" => 10,
			"category" => "SolverSettings",
			"description" => "Level of information stored in reports when written to disk.",
		),
		"OutputSubstrates" => Dict(
			"type" => Bool,
			"variable_name" => "output_substates",
			"category" => "SolverSettings",
			"description" => "Store substates (between report steps) as field on each state.",
		),
	)
	return meta_data

end
